from fastapi import FastAPI, UploadFile, Request, File, Form
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Optional
from app.utils.helpers import (
    extract_github_data,
    scrape_portfolio,
    extract_jd_keywords,
    pdf_to_text,
    generate_resume_json
)
from app.workflow import generate_resume_workflow,call_tracker  

from dotenv import load_dotenv
import os
load_dotenv()
os.environ["OPENAI_API_KEY"] = os.getenv('OPENAI_API_KEY')

app = FastAPI(title="Intelligent Resume Builder")

class JDRequest(BaseModel):
    jd: str  # Single job description string


@app.get("/test/github")
def test_github(url: str):
    return extract_github_data(url)

@app.get("/test/portfolio")
def test_portfolio(url: str):
    return scrape_portfolio(url)


@app.post("/test/jd-keywords")
async def test_jd_keywords(request: Request):
    jd_text = await request.body()
    jd_str = jd_text.decode("utf-8")
    keywords = extract_jd_keywords(jd_str)
    return JSONResponse(content={"keywords": keywords})

@app.post("/test/pdf-to-text")
async def test_pdf_to_text(file: UploadFile):
    text = await pdf_to_text(file)
    return {"text": text}

# ===============================
# MAIN SUPERVISOR RESUME ROUTE
# ===============================

# @app.post("/generate-resume")
# async def generate_resume_complete(
#     github_url: Optional[str] = Form(None),
#     portfolio_url: Optional[str] = Form(None),
#     job_description: Optional[str] = Form(None),
#     old_resume: Optional[UploadFile] = File(None),
#     user_feedback: Optional[str] = Form(None),
#     user_additions: Optional[str] = Form(None)
# ):
#     """
#     Complete resume generation route that takes ALL possible inputs from user
#     and passes them to the supervisor workflow to generate final JSON resume.
    
#     Args:
#         github_url: GitHub profile URL (optional)
#         portfolio_url: Portfolio website URL (optional) 
#         job_description: Target job description text (optional)
#         old_resume: Existing resume PDF file (optional)
#         user_feedback: User feedback for resume improvements (optional)
#         user_additions: Additional information to include (optional)
    
#     Returns:
#         JSON resume generated by supervisor workflow
#     """
#     try:
#         # Extract text from uploaded resume if provided
#         old_resume_text = None
#         if old_resume:
#             old_resume_text = await pdf_to_text(old_resume)
        
#         # Execute the supervisor workflow with all inputs
#         workflow_result = await generate_resume_workflow(
#             github_url=github_url,
#             portfolio_url=portfolio_url,
#             job_description=job_description,
#             old_resume_text=old_resume_text,
#             user_feedback=user_feedback,
#             user_additions=user_additions
#         )
        
#         print("Workflow result:", workflow_result)  # Debugging log
        
#         # Convert workflow result to JSON serializable format
#         def extract_serializable_data(result):
#             """Convert LangChain messages to serializable format"""
#             if isinstance(result, dict) and 'messages' in result:
#                 serializable_messages = []
#                 for msg in result['messages']:
#                     if hasattr(msg, 'content'):
#                         serializable_messages.append({
#                             'role': getattr(msg, 'name', type(msg).__name__),
#                             'content': msg.content,
#                             'type': type(msg).__name__
#                         })
#                 return {
#                     'messages': serializable_messages,
#                     'total_messages': len(serializable_messages)
#                 }
#             return result
        
#         # Convert to serializable format
#         serializable_result = extract_serializable_data(workflow_result)
        
#         # Extract final output message
#         final_message = "Resume generation completed"
#         if serializable_result.get('messages'):
#             # Get the last message content
#             final_message = serializable_result['messages'][-1].get('content', final_message)
        
#         # Return JSON serializable response
#         return JSONResponse(content={
#             "status": "success",
#             "message": "Resume generated successfully",
#             "final_output": final_message,
#             "workflow_summary": {
#                 "total_messages": serializable_result.get('total_messages', 0),
#                 "workflow_completed": True
#             },
#             "inputs_received": {
#                 "github_url": bool(github_url),
#                 "portfolio_url": bool(portfolio_url),
#                 "job_description": bool(job_description),
#                 "old_resume_uploaded": bool(old_resume),
#                 "user_feedback": bool(user_feedback),
#                 "user_additions": bool(user_additions)
#             }
#         })
        
#     except Exception as e:
#         print(f"Error during resume generation: {e}")  # Log the error
#         return JSONResponse(
#             status_code=500,
#             content={
#                 "status": "error",
#                 "message": f"Error generating resume: {str(e)}",
#                 "error_type": type(e).__name__,
#                 "inputs_received": {
#                     "github_url": bool(github_url),
#                     "portfolio_url": bool(portfolio_url),
#                     "job_description": bool(job_description),
#                     "old_resume_uploaded": bool(old_resume),
#                     "user_feedback": bool(user_feedback),
#                     "user_additions": bool(user_additions)
#                 }
#             }
#         )
@app.post("/generate-resume")
async def generate_resume_complete(
    github_url: Optional[str] = Form(None),
    portfolio_url: Optional[str] = Form(None),
    job_description: Optional[str] = Form(None),
    old_resume: Optional[UploadFile] = File(None),
    user_feedback: Optional[str] = Form(None),
    user_additions: Optional[str] = Form(None)
):
    """
    Complete resume generation route that returns the generated resume JSON.
    """
    try:
        # Extract text from uploaded resume if provided
        old_resume_text = None
        if old_resume:
            old_resume_text = await pdf_to_text(old_resume)
        
        # Execute the supervisor workflow with all inputs
        workflow_result = await generate_resume_workflow(
            github_url=github_url,
            portfolio_url=portfolio_url,
            job_description=job_description,
            old_resume_text=old_resume_text,
            user_feedback=user_feedback,
            user_additions=user_additions
        )
        
        # Get the actual generated resume JSON
        resume_json_str = await call_tracker.get_task_result("resume_json_data")
        
        if not resume_json_str:
            raise Exception("No resume JSON was generated")
        
        # Parse the JSON string back to dict
        import json
        try:
            resume_json = json.loads(resume_json_str)
            return JSONResponse(content=resume_json)
        except json.JSONDecodeError:
            # If it's not valid JSON, return as is
            return JSONResponse(content={"resume_data": resume_json_str})
        
    except Exception as e:
        print(f"Error during resume generation: {e}")
        return JSONResponse(
            status_code=500,
            content={
                "status": "error",
                "message": f"Error generating resume: {str(e)}"
            }
        )


from pydantic import BaseModel
from typing import List

class ResumeRequest(BaseModel):
    github_data: str
    portfolio_data: str
    jd_keywords: List[str]
    old_resume: str
    user_additions: str
    user_feedback: str

@app.post("/test/generate-resume")
async def test_generate_resume(data: ResumeRequest):
    resume = generate_resume_json(
        github_data=data.github_data,
        portfolio_data=data.portfolio_data,
        jd_keywords=data.jd_keywords,
        old_resume=data.old_resume,
        user_additions=data.user_additions,
        user_feedback=data.user_feedback
    )
    return JSONResponse(content=resume)
